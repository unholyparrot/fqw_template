\section{Сравнение}

\subsection{Виды критериев}
    В целом, сравнения двух приложений и определения преимущества того или иного подхода (монолитного или микросервисного) можно учитывать следующие параметры:

    \begin{itemize}
        \item Масштабирование
        \item Производительность
        \item Отказоустойчивость
        \item Надёжность
        \item Переиспользуемость
        \item Команда
        \item Скорость разработки
        \item Совместимость
        \item Переносимость
        \item Наблюдаемость
        \item Потребление ресурсов
    \end{itemize}

    Данные параметры были взяты из исследований: "...возможность быстро обнаружить неполадки..." \cite{шитько2017проектирование} (т. е. наблюдаемость) и "...обеспечить отказоустойчивость и балансировку нагрузки..." и "...требуется больше вычислительных ресурсов для функционирования множества сервисов..." \cite{артамонов2016разработка} (отказоустойчивость и потребление ресурсов). Также они были взяты из требований (описанных в разделе Реализация) и из пркатической разработки.

    Тем не менее, не все данные критерии актуальны в условиях низкой загруженности. В большинстве случаев низкая загрузка возникает или в начале разработки проектов, или если проект был нацелен на небольшое количество пользователей и/или все запросы легковесные и редкие. Рассмотрим с данной точки зрения приведённые выше критерии и выберем подходящие.

    \begin{enumerate}
        \item Масштабирование: Процесс увеличения или уменьшения ресурсов системы для поддержания производительности под изменяющейся нагрузкой. Не подходит, потому что в условиях низкой загрузки нет необходимости увеличивать ресурсы системы для поддержания производительности.
        \item Производительность: Мера эффективности системы, отражающая скорость выполнения запросов и обработки данных. Разумеется, данный критерий возможно применять в любых условиях, но для низкой загруженности не столь важна скорость обработки запросов. Не подходит, так как фокус данной работы находится на другом.
        \item Отказоустойчивость: Способность системы продолжать функционировать корректно при возникновении сбоев или отказов в её компонентах. Аналогично производительности, отказоустойчивость полезна для любого проекта; тем не менее, данная работа нацелена на анализ условий, специфичных для низкой загруженности. Не подходит, ввиду отсутствия жёстких требований на отказоустойчивость в небольших проектах.
        \item Надёжность: Вероятность того, что система будет функционировать безотказно и правильно в течение определённого периода времени. Не подходит по причинам, сходным с отказоустойчивостью.
        \item Переиспользуемость: Способность компонентов системы быть использованными в различных контекстах и приложениях без модификаций. Здесь подходят те же аргументы - данная характеристика важнее для высокой производительности, а также её уже обсуждали в других работах, приведённых выше. Не подходит ввиду неисключительности для низкой загруженности.
        \item Команда: Группа специалистов, работающих совместно над разработкой, поддержкой и улучшением веб-приложения. Подходит, так как эффективность и взаимодействие команды важны для любого проекта, независимо от уровня загрузки.
        \item Скорость разработки: Время, затрачиваемое на создание, тестирование и внедрение функционала или системы в целом. Подходит, потому что быстрое создание и внедрение функционала важно на всех этапах проекта, особенно в условиях ограниченных ресурсов и низкой загрузки.
        \item Совместимость: Способность системы или её компонентов взаимодействовать и работать с другими системами или компонентами без конфликтов. Подходит, потому что система должна взаимодействовать с другими системами и компонентами корректно, независимо от уровня нагрузки.
        \item Переносимость: Способность системы или её компонентов быть перенесёнными и запущенными на различных платформах или в разных средах без значительных изменений. Подходит, так как возможность переноса системы на другие платформы или среды важна для гибкости и адаптации проекта, независимо от текущей загрузки. Более того, в условиях новых проектов важнее уметь быстро менять среду выполнения для экспериментирования или экономии бюджетных средств.
        \item Наблюдаемость: Возможность отслеживания состояния системы и её компонентов через сбор и анализ метрик, логов и трассировок. Подходит, поскольку мониторинг состояния системы и её компонентов помогает выявлять и устранять проблемы на ранних стадиях, что важно при любой нагрузке.
        \item Потребление ресурсов: Объём вычислительных ресурсов (таких как CPU, память, дисковое пространство и сетевой трафик), используемых системой во время её работы. Подходит, так как эффективность использования ресурсов важна при любой загрузке для оптимизации затрат и производительности.
    \end{enumerate}

    Теперь, когда мы выделили 6 основных параметров для сравнения, перейдём к самому анализу.

\subsection{Команда и скорость разработки}
    Эффективность команды и скорость разработки играют ключевую роль в успехе любого проекта. Эти факторы особенно важны в условиях низкой загрузки, где ресурсы ограничены и необходимо быстрое внедрение решений. Рассмотрим эти аспекты на примере моих двух проектов.

    В проекте с монолитной архитектурой наша команда разработчиков работала над единой кодовой базой. Это позволило легко управлять и координировать работу, так как все компоненты системы интегрированы в одном месте. Благодаря этому, внедрение новых функций и исправление багов происходило быстрее, так как изменения требовали минимальных изменений в кодовой базе. Команда сосредоточилась на общем контексте проекта, что упрощает коммуникацию и уменьшает риск недопонимания. Однако монолитная архитектура имеет и свои недостатки. С увеличением сложности проекта начали возникать проблемы с масштабируемостью самой команды - управление большими монолитными кодовыми базами стало сложным, методы и классы стали разрастаться, было сложнее следить за тем, чтобы соблюдались принципы SOLID. Всё это стало замедлять разработку. При внесении изменений в одну часть системы возникали непредвиденные последствия в других частях, требующие дополнительного времени на тестирование и отладку.
    
    В проекте с микросервисной архитектурой наша команда была разбита на небольшие группы, каждая из которых отвечала за определенный набор микросервисов. Это позволяило каждому члену команды работать более автономно и параллельно, что, безусловно, ускорило разработку отдельных компонентов. Разделение ответственности также уменьшило зависимость между командами, улучшив гибкость и адаптивность процесса разработки. Также, различные микросервисы использовали различные технологии и инструменты для своих задач - так, один из сервисов отвечал за регистрацию и авторизацию с помощью стороннего сервиса Keycloak, в результате чего потребовались дополнительная библиотека keycloak-admin-client. Благодаря архитектуре микросервисов, остальные проекты не должны были менять свои зависимости для поддержки конкретной версии данной библиотеки. Тем не менее, микросервисная архитектура добавила сложности в координацию и интеграцию работы различных команд. Необходимо было постоянно обеспечивать совместимость и взаимодействие между микросервисами, что требовало дополнительного времени и усилий. Кроме того, для нашей маленькой команды и небольшого проекта, микросервисы стали избыточными и привели к излишней сложности и увеличению времени разработки из-за необходимости настройки и поддержки инфраструктуры. Так, мы были вынуждены привлечь дополнительного специалиста по docker и архитектора баз данных для помощи в правильном построении и связи баз данных отдельных микросервисов.
    
    Сравнивая два проекта, можно отметить, что в условиях низкой загрузки монолитная архитектура предоставляет значительные преимущества в плане скорости разработки. Единая кодовая база и простота управления позволили команде быстро вносить изменения и внедрять новые функции, что особенно важно для небольших команд, где каждая минута на счету и важно как можно быстрее доставить продукт на рынок.
    
    Микросервисная архитектура, хотя она и может быть более гибкой и адаптивной в долгосрочной перспективе, особенно по мере роста проекта и увеличения команды, в условиях низкой загрузки и ограниченных ресурсов лишь замедляла процесс разработки из-за сложностей координации и управления распределенной системой. Таким образом, по критерию "Команда и скорость разработки" проект с монолитной архитектурой оказывается предпочтительнее в условиях низкой загрузки.

\subsection{Совместимость}
    Рассмотрим, насколько сильно отличается способность системы или её компонентов взаимодействовать и работать с другими системами или компонентами без конфликтов в зависимости от архитектуры. В веб-разработке совместимость включает взаимодействие между различными сервисами, базами данных, внешними API (например, Keycloak) и другими системами.

    В проекте с монолитной архитектурой все компоненты системы находятся в одной кодовой базе и тесно связаны между собой. Все классы были написаны в рамках одного java проекта, с одним общим pom.xml. Совместимость здесь обеспечена на уровне общей кодовой базы и единого окружения выполнения. Все модули разрабатывались с учетом единой платформы и стандартов, что упростило интеграцию и взаимодействие между ними. Так, например, классам OrderController и PatientController, которые отвечали за принятие запросов касающихся заказов и управления данными пациентов, понадобилось обоим запрашивать данные о пользователе, за которые отвечал UserController. В монолитной архитектуре это решилось простым запросом к общему репозиторию UserRepository. Таким образом, при внесении изменений в один компонент, разработчики могут легко протестировать влияние этих изменений на всю систему. Однако монолитная архитектура имеет свои ограничения в плане совместимости с внешними системами. Интеграция с внешними API и сервисами требовала значительных усилий, так как любые изменения или обновления этих систем могут требовали соответствующих изменений в остальных классах. Также, внедрение новых технологий было затруднено, так как обновление одной библиотеки могло тянуть за собой изменения по всему проекту - что произошло, например, при обновлении библиотеки jakarta.xml.bind-api с версии 3.x до 4.x, когда  вся система была вынуждена поддержать эти изменения.
    
    В проекте с микросервисной архитектурой каждый сервис является независимой сущностью, которая взаимодействует с другими сервисами через четко определенные интерфейсы - в нашем случае, через API. Это позволило использовать различные технологии и платформы для каждого микросервиса, что повысило гибкость и адаптивность системы. Например, микросервисы использовали разные библиотеки и даже разные версии базовой библиотеки spring-boot, а взаимодействие между ними осуществлялось через REST. Микросервисная архитектура значительно улучшило совместимость и с внешними системами - каждый микросервис был адаптирован для интеграции со своими внешними API и сервисами без влияния на другие части системы, что позволило быстрее внедрять новые технологии и адаптироваться к изменениям во внешних системах. Конечно, такая архитектура требовала дополнительных усилий для обеспечения совместимости между самими микросервисами, включая управление версиями API и мониторинг взаимодействия между ними, но совместимость была на порядок выше.
    
    Сравнивая два проекта, видно, что микросервисная архитектура предоставляет значительные преимущества в плане совместимости. Независимость микросервисов позволяет легко адаптироваться к изменениям во внешних системах и использовать различные технологии для каждого компонента. Это особенно полезно в условиях, когда требуется интеграция с множеством различных систем и API. Хотя монолитная архитектура и может обеспечить более простое управление совместимостью внутри самой системы, так как все компоненты находятся в одной кодовой базе и работают в едином окружении, но при интеграции с внешними системами и обновлении технологий могут возникать значительные сложности, требующие больших усилий для поддержания совместимости. Следовательно, по критерию "Совместимость" проект с микросервисной архитектурой оказывается предпочтительнее.

\subsection{Переносимость}
    Перейдём к рассмотрению способности системы или её компонентов быть перенесёнными и запущенными на различных платформах или в разных средах без значительных изменений. В контексте веб-разработки переносимость играет важную роль при развертывании приложений на различных серверных платформах, облачных инфраструктурах или при миграции между ними.
    
    В проекте с монолитной архитектурой вся система была разработана и развернута как единое целое. Это означает, что при переносе приложения на другую платформу необходимо обеспечить совместимость всей кодовой базы и инфраструктуры с новой средой. Монолитные приложения часто зависят от специфических конфигураций и окружений, что может затруднить их переносимость. Так получилось и в случае нашего проекта - в определённый момент потребовалось осуществить перенос приложения с Ubuntu16 на Ubuntu20. Ввиду изменений в операционной системе, библиотеки и конфигурации сервера потребовали значительных изменений в кодовой базе и настройках. Тем не менее, монолитная архитектура имеет преимущества в плане простоты развертывания. Поскольку вся система развертывается как единое целое, процесс миграции может быть более прямолинейным. Тем не менее, есть очевидная проблема с конкретно нашим решением: ввиду специфики разработки мы не использовали такие инструменты контейнеризации как Docker, чтобы упаковать монолитное приложение и его зависимости в контейнер, из-за чего и возникло большинство проблем.
    
    В проекте с микросервисной архитектурой каждый микросервис является независимой сущностью, которая может быть развернута и запущена на различных платформах и в различных средах. Это существенно улучшило переносимость системы, так как каждый микросервис может быть адаптирован к специфическим требованиям целевой платформы. Например, один из наших микросервисов разворачивался на нашем локальном сервере, а остальные - на серверах Selectel. Каждый микросервис был упакован в собственный контейнер, что позволило легко переносить его между различными средами без изменения кода. Более того, инструменты оркестрации позволили управлять развертыванием и масштабированием микросервисов в различных средах, обеспечив гибкость и адаптивность системы. Однако, управление множеством микросервисов требует дополнительных усилий и ресурсов для обеспечения их взаимодействия и мониторинга, а выгода, получаемая от возможности масштабирования, минимальна в условиях низкой загруженности.
    
    В результате анализа видно, что, несмотря на очевидные значительные преимущества в плане переносимости у микросервисного проекта в конкретно нашем случае, большинство проблем с переносимостью решаются стандартными инструментами контейнеризации. Независимость микросервисов хоть и позволяет легко адаптировать и развертывать их на различных платформах и в различных средах, монолитная архитектура может обеспечить более простое развертывание в тех случаях, когда система разрабатывается и развертывается в статической и неизменной среде.  Таким образом, по критерию "Совместимость" проекты находятся в сравнимом положении.

\subsection{Наблюдаемость}
    Теперь рассмотрим наблюдаемость — возможность отслеживания состояния системы и её компонентов через сбор и анализ метрик, логов и трассировок. Наблюдаемость играет ключевую роль в поддержке и управлении веб-приложениями, обеспечивая своевременное выявление причин проблем и проведение оперативной отладки.
    
    В проекте с монолитной архитектурой вся система работает как единое целое, что упрощает процесс мониторинга и сбора данных. Вся логика приложения и данные находятся в одном месте, что позволяет централизовать логи, метрики и трассировки. Инструменты мониторинга, такие как Jprofiler, легко интегрируются с монолитным приложением, предоставляя всесторонний обзор его состояния. Однако, несмотря на упрощенный процесс мониторинга, в больших и сложных монолитных системах объем логов и метрик может быть значительным, что затрудняет анализ и выявление проблем. Кроме того, любые изменения в мониторинговых инструментах, опять же, могут потребовать изменения в коде всей системы, что усложняет управление. Наконец, ввиду отсутствия физического разделения логически разных систем (что происходит в микросервисах) становится сложнее выделить конкретные точки связей между классами и методами, что приводит к более запутанному процессу отладки.
    
    В проекте с микросервисной архитектурой каждый сервис работает независимо, что увеличило сложность наблюдаемости: каждый микросервис генерировал свои собственные логи, метрики и трассировки, что потребовало разработки системы для агрегации и анализа данных из множества источников, для чего были использованы инструменты, написанные на bash и Python. Кроме этого, поскольку каждый микросервис отслеживается отдельно, это позволяет более точно выявлять и устранять проблемы в конкретных компонентах системы, хотя это и требует дополнительных усилий для настройки и управления системой наблюдаемости, включая координацию между микросервисами и обеспечение совместимости данных.
    
    Сравнив два проекта, видно, что монолитная архитектура выигрывает у микросервисной. Хотя микросервисы и предоставляют более детализированную систему наблюдаемости, более простая и централизованная систему наблюдаемости монолита серьёзно упрощает сбор и анализ данных. По критерию "Наблюдаемость" проект с монолитной архитектурой оказывается предпочтительнее

\subsection{Потребление ресурсов}
    Последний признак, рассматриваемый в данной работе — это объем вычислительных ресурсов (таких как CPU, память, дисковое пространство и сетевой трафик), используемых системой во время её работы. Приложения могут значительно различаться по эффективности использования ресурсов в зависимости от выбранной архитектуры, даже при прочих равных параметрах.
    
    В проекте с монолитной архитектурой все компоненты приложения работают в рамках одной кодовой базы и исполняются как единое целое. Это может быть более эффективно с точки зрения использования ресурсов, так как все компоненты приложения могут совместно использовать общие ресурсы, такие как память и процессорное время. В монолитной архитектуре отсутствуют и накладные расходы на межсервисные коммуникации, которые могут быть значительными в микросервисных системах. Однако, монолитная архитектура поставляется единым блоком, что означает большое потребление ресурсов на одном сервере. Поскольку вся система исполняется в одном процессе или наборе процессов, масштабирование отдельных компонентов невозможно, что привело к ситуации, когда для масштабирования одного компонента приходилось масштабировать всю систему, что неэффективно с точки зрения использования ресурсов и приводит к неоптимальным тратам бюджета.
    
    В проекте с микросервисной архитектурой каждый микросервис работает независимо и может быть развернут в собственном окружении. Это позволило иметь несколько более слабых серверов, которые уже выбираются и настраиваются отдельно в зависимости от конкретных требований. Например, микросервис company-data, отвечающий за основную обработку информации, был размещён на производительном сервере с мощным CPU и забирал наибольшую нагрузку на себя, тогда как микросервис import-data, занимающийся хранением и транспортировкой данных, использовал больший объем памяти и дискового пространства. Однако, микросервисная архитектура вводит дополнительные накладные расходы на межсервисные коммуникации. Каждый микросервис должен взаимодействовать с другими микросервисами через сеть, что требует дополнительных ресурсов и снижает общую производительность системы. Также, каждая независимая служба требует собственного набора ресурсов, таких как память и процессорное время, что привело к увеличению общего потребления ресурсов по сравнению с монолитной архитектурой.
    
    Получаем, что, с одной стороны, монолитная архитектура более эффективна с точки зрения общего потребления ресурсов. Совместное использование ресурсов и отсутствие накладных расходов на межсервисные коммуникации позволяют монолитному приложению работать более эффективно в условиях ограниченных ресурсов. С другой стороны, микросервисная архитектура предоставляет гибкость в управлении и масштабировании отдельных компонентов, что позволяет оптимизировать использование ресурсов для каждого микросервиса. Для малонагруженных систем данные архитектурные подходы являются сравнимыми по успешности
        
% Обязательно добавляем это в конце каждой секции, чтобы 
% обеспечить переход на новую страницу
\clearpage