\section{Сравнение}

\subsection{Виды критериев}
    В целом, сравнения двух приложений и определения преимущества того или иного подхода (монолитного или микросервисного) можно учитывать следующие параметры:

    \begin{itemize}
        \item Масштабирование
        \item Производительность
        \item Отказоустойчивость
        \item Надёжность
        \item Переиспользуемость
        \item Команда
        \item Скорость разработки
        \item Совместимость
        \item Переносимость
        \item Наблюдаемость
        \item Потребление ресурсов
    \end{itemize}

    Данные параметры были взяты из исследований: "...возможность быстро обнаружить неполадки..." \cite{шитько2017проектирование} (т. е. наблюдаемость) и "...обеспечить отказоустойчивость и балансировку нагрузки..." и "...требуется больше вычислительных ресурсов для функционирования множества сервисов..." \cite{артамонов2016разработка} (отказоустойчивость и потребление ресурсов). Также они были взяты из требований (описанных в разделе Реализация) и из пркатической разработки.

    Тем не менее, не все данные критерии актуальны в условиях низкой загруженности. В большинстве случаев низкая загрузка возникает или в начале разработки проектов, или если проект был нацелен на небольшое количество пользователей и/или все запросы легковесные и редкие. Рассмотрим с данной точки зрения приведённые выше критерии и выберем подходящие.

    \begin{enumerate}
        \item Масштабирование: Процесс увеличения или уменьшения ресурсов системы для поддержания производительности под изменяющейся нагрузкой. Не подходит, потому что в условиях низкой загрузки нет необходимости увеличивать ресурсы системы для поддержания производительности.
        \item Производительность: Мера эффективности системы, отражающая скорость выполнения запросов и обработки данных. Разумеется, данный критерий возможно применять в любых условиях, но для низкой загруженности не столь важна скорость обработки запросов. Не подходит, так как фокус данной работы находится на другом.
        \item Отказоустойчивость: Способность системы продолжать функционировать корректно при возникновении сбоев или отказов в её компонентах. Аналогично производительности, отказоустойчивость полезна для любого проекта; тем не менее, данная работа нацелена на анализ условий, специфичных для низкой загруженности. Не подходит, ввиду отсутствия жёстких требований на отказоустойчивость в небольших проектах.
        \item Надёжность: Вероятность того, что система будет функционировать безотказно и правильно в течение определённого периода времени. Не подходит по причинам, сходным с отказоустойчивостью.
        \item Переиспользуемость: Способность компонентов системы быть использованными в различных контекстах и приложениях без модификаций. Здесь подходят те же аргументы - данная характеристика важнее для высокой производительности, а также её уже обсуждали в других работах, приведённых выше. Не подходит ввиду неисключительности для низкой загруженности.
        \item Команда: Группа специалистов, работающих совместно над разработкой, поддержкой и улучшением веб-приложения. Подходит, так как эффективность и взаимодействие команды важны для любого проекта, независимо от уровня загрузки.
        \item Скорость разработки: Время, затрачиваемое на создание, тестирование и внедрение функционала или системы в целом. Подходит, потому что быстрое создание и внедрение функционала важно на всех этапах проекта, особенно в условиях ограниченных ресурсов и низкой загрузки.
        \item Совместимость: Способность системы или её компонентов взаимодействовать и работать с другими системами или компонентами без конфликтов. Подходит, потому что система должна взаимодействовать с другими системами и компонентами корректно, независимо от уровня нагрузки.
        \item Переносимость: Способность системы или её компонентов быть перенесёнными и запущенными на различных платформах или в разных средах без значительных изменений. Подходит, так как возможность переноса системы на другие платформы или среды важна для гибкости и адаптации проекта, независимо от текущей загрузки. Более того, в условиях новых проектов важнее уметь быстро менять среду выполнения для экспериментирования или экономии бюджетных средств.
        \item Наблюдаемость: Возможность отслеживания состояния системы и её компонентов через сбор и анализ метрик, логов и трассировок. Подходит, поскольку мониторинг состояния системы и её компонентов помогает выявлять и устранять проблемы на ранних стадиях, что важно при любой нагрузке.
        \item Потребление ресурсов: Объём вычислительных ресурсов (таких как CPU, память, дисковое пространство и сетевой трафик), используемых системой во время её работы. Подходит, так как эффективность использования ресурсов важна при любой загрузке для оптимизации затрат и производительности.
    \end{enumerate}

    Теперь, когда мы выделили 6 основных параметров для сравнения, перейдём к самому анализу.

\subsection{Команда и скорость разработки}
    Эффективность команды и скорость разработки играют ключевую роль в успехе любого проекта. Эти факторы особенно важны в условиях низкой загрузки, где ресурсы ограничены и необходимо быстрое внедрение решений. Рассмотрим эти аспекты на примере моих двух проектов.

    В проекте с монолитной архитектурой наша команда разработчиков работала над единой кодовой базой. Это позволило легко управлять и координировать работу, так как все компоненты системы интегрированы в одном месте. Благодаря этому, внедрение новых функций и исправление багов происходило быстрее, так как изменения требовали минимальных изменений в кодовой базе. Команда сосредоточилась на общем контексте проекта, что упрощает коммуникацию и уменьшает риск недопонимания. Однако монолитная архитектура имеет и свои недостатки. С увеличением сложности проекта начали возникать проблемы с масштабируемостью самой команды - управление большими монолитными кодовыми базами стало сложным, методы и классы стали разрастаться, было сложнее следить за тем, чтобы соблюдались принципы SOLID. Всё это стало замедлять разработку. При внесении изменений в одну часть системы возникали непредвиденные последствия в других частях, требующие дополнительного времени на тестирование и отладку.
    
    В проекте с микросервисной архитектурой наша команда была разбита на небольшие группы, каждая из которых отвечала за определенный набор микросервисов. Это позволяило каждому члену команды работать более автономно и параллельно, что, безусловно, ускорило разработку отдельных компонентов. Разделение ответственности также уменьшило зависимость между командами, улучшив гибкость и адаптивность процесса разработки. Также, различные микросервисы использовали различные технологии и инструменты для своих задач - так, один из сервисов отвечал за регистрацию и авторизацию с помощью стороннего сервиса Keycloak, в результате чего потребовались дополнительная библиотека keycloak-admin-client. Благодаря архитектуре микросервисов, остальные проекты не должны были менять свои зависимости для поддержки конкретной версии данной библиотеки. Тем не менее, микросервисная архитектура добавила сложности в координацию и интеграцию работы различных команд. Необходимо было постоянно обеспечивать совместимость и взаимодействие между микросервисами, что требовало дополнительного времени и усилий. Кроме того, для нашей маленькой команды и небольшого проекта, микросервисы стали избыточными и привели к излишней сложности и увеличению времени разработки из-за необходимости настройки и поддержки инфраструктуры. Так, мы были вынуждены привлечь дополнительного специалиста по docker и архитектора баз данных для помощи в правильном построении и связи баз данных отдельных микросервисов.
    
    Сравнивая два проекта, можно отметить, что в условиях низкой загрузки монолитная архитектура предоставляет значительные преимущества в плане скорости разработки. Единая кодовая база и простота управления позволили команде быстро вносить изменения и внедрять новые функции, что особенно важно для небольших команд, где каждая минута на счету и важно как можно быстрее доставить продукт на рынок.
    
    Микросервисная архитектура, хотя она и может быть более гибкой и адаптивной в долгосрочной перспективе, особенно по мере роста проекта и увеличения команды, в условиях низкой загрузки и ограниченных ресурсов лишь замедляла процесс разработки из-за сложностей координации и управления распределенной системой. Таким образом, по критерию "Команда и скорость разработки" проект с монолитной архитектурой оказывается предпочтительнее в условиях низкой загрузки.

\subsection{Совместимость}
    TODO

\subsection{Переносимость}
    TODO

\subsection{Наблюдаемость}
    TODO

\subsection{Потребление ресурсов}
    TODO

\subsection{Результаты}
    TODO


--------------------------------------




Функциональные требования:

    Функциональность приложения: Сравнение функциональных возможностей и способности приложений решать задачи и удовлетворять потребности пользователей.
    Гибкость и масштабируемость: Оценка возможности приложений адаптироваться к изменяющимся требованиям и масштабироваться для работы с различными объемами данных и нагрузками.
    Изоляция компонентов: Учитывание степени изоляции компонентов приложения и их независимости друг от друга для обеспечения гибкости разработки и поддержки.
    Развитие и поддержка: Оценка удобства разработки новых функций и поддержки существующих в рамках выбранной архитектуры.
    Интеграция с внешними системами: Учет возможности интеграции приложений с другими системами и сервисами для обеспечения расширенных функциональных возможностей.

Нефункциональные требования:

    Производительность: Сравнение производительности приложений в условиях различной нагрузки и объема данных.
    Отказоустойчивость и надежность: Оценка способности приложений обрабатывать ошибки и отказы без серьезных последствий для работы системы в целом.
    Безопасность: Анализ мер безопасности и возможности обеспечения защиты данных и системы от внешних угроз.
    Скорость развертывания и обновления: Оценка скорости и удобства развертывания новых версий приложений и обновлений.
    Затраты на разработку и поддержку: Учет затрат на разработку, развертывание и поддержку приложений в течение их жизненного цикла.

Учитывая эти параметры, можно определить, какой подход (монолитный или микросервисный) лучше соответствует требованиям и целям конкретного проекта.

Для объективной оценки и сравнения монолитного и микросервисного подходов по нефункциональным требованиям можно использовать следующие критерии:

    Безопасность:
        Монолитный подход: Аудит безопасности приложения в целом, включая проверку уязвимостей и обеспечение соответствия стандартам безопасности.
        Микросервисный подход: Анализ безопасности каждого сервиса отдельно, а также проверка наличия механизмов защиты данных при передаче между сервисами.

    Производительность:
        Монолитный подход: Оценка производительности единого приложения под нагрузкой, включая время отклика и скорость выполнения различных операций.
        Микросервисный подход: Оценка производительности каждого сервиса отдельно и их взаимодействия, а также оценка пропускной способности сети между сервисами.

    Масштабируемость:
        Монолитный подход: Оценка возможности масштабирования всего приложения целиком, включая возможность горизонтального и вертикального масштабирования.
        Микросервисный подход: Оценка гибкости и простоты масштабирования отдельных сервисов в зависимости от нагрузки на них, а также возможность автоматического масштабирования при необходимости.

    Доступность:
        Монолитный подход: Анализ уязвимых мест и резервных систем для обеспечения доступности приложения в случае отказов или сбоев.
        Микросервисный подход: Обеспечение высокой доступности путем дублирования и отказоустойчивости каждого сервиса, а также балансировки нагрузки между ними.

    Техническое обслуживание:
        Монолитный подход: Оценка сложности и затрат на обновление и поддержку всего приложения целиком, включая время, ресурсы и возможность автоматизации процессов.
        Микросервисный подход: Оценка сложности и затрат на обновление и поддержку каждого сервиса отдельно, а также возможность автоматизации и оркестрации процессов управления сервисами.

    Переносимость:
        Монолитный подход: Оценка возможности переноса приложения на различные платформы без необходимости крупных изменений в коде или архитектуре.
        Микросервисный подход: Оценка возможности переноса и совместимости каждого сервиса с различными платформами и средами выполнения.

    Надежность:
        Монолитный подход: Оценка стабильности и надежности работы всего приложения в целом, включая отказоустойчивость и восстановление после сбоев.
        Микросервисный подход: Оценка надежности каждого сервиса и их взаимодействия, а также механизмов обработки ошибок и восстановления после отказов.

    Юзабилити:
        Монолитный подход: Оценка удобства использования интерфейса и функциональности приложения для пользователей.
        Микросервисный подход: Анализ удобства использования и взаимодействия различных сервисов в рамках приложения для разработчиков и администраторов системы.

    Совместимость:
        Монолитный подход: Оценка совместимости приложения с другими системами и сервисами, с которыми оно взаимодействует.
        Микросервисный подход: Оценка совместимости каждого сервиса с другими системами и сервисами, а также возможность интеграции и обмена данными между ними.

    Юридические вопросы:
        Монолитный подход: Проверка соответствия всей архитектуры приложения применимым законам и правилам.
        Микросервисный подход: Анализ соответствия каждого сервиса применимым законам и правилам, а также возможность управления доступом к данным и сервисам с точки зрения правовых норм.

Анализ этих критериев для каждого из проектов позволит объективно оценить преимущества и недостатки монолитного и микросервисного подходов и выбрать наиболее подходящий вариант для конкретного случая.

\subsection{Безопасность}

Монолитный подход:

    Аудит безопасности приложения: Провести комплексный аудит безопасности приложения, включая анализ уязвимостей кода, проверку на соответствие стандартам безопасности и наличие механизмов защиты.
    Обеспечение безопасности данных: Оценить методы шифрования и защиты данных при хранении и передаче, а также наличие механизмов контроля доступа к конфиденциальной информации.

Микросервисный подход:

    Анализ безопасности каждого сервиса: Проверить каждый сервис на наличие уязвимостей и возможные точки входа для атак, а также оценить механизмы обеспечения безопасности внутри сервиса.
    Защита взаимодействия между сервисами: Обеспечить безопасность передачи данных между сервисами, включая использование протоколов шифрования и аутентификации.

Вывод:

    В монолитном подходе безопасность приложения оценивается как единое целое, что может упростить процесс аудита и обеспечения безопасности, но также повышает риск распространения уязвимостей на всю систему.
    В микросервисном подходе необходимо обеспечить безопасность каждого сервиса отдельно, что требует дополнительных усилий, но также обеспечивает более гибкий и гранулярный контроль над безопасностью в целом.

\subsection{Производительность}

Монолитный подход:

    Тестирование времени отклика: Измерить время отклика приложения на запросы пользователей при различных нагрузках для определения скорости работы системы.
    Анализ использования ресурсов: Оценить использование процессора, памяти и сети приложением во время работы для выявления узких мест и возможных улучшений.
    Скорость обработки запросов: Измерить время выполнения различных операций приложения, таких как загрузка страниц, выполнение запросов к базе данных и обработка данных.

Микросервисный подход:

    Тестирование производительности каждого сервиса: Измерить время отклика и производительность каждого сервиса отдельно при различных нагрузках для определения уровня его эффективности.
    Анализ времени передачи данных между сервисами: Оценить время передачи данных между сервисами и задержки в коммуникации для определения эффективности взаимодействия.
    Скорость обработки запросов и сборка данных: Измерить время выполнения запросов, необходимых для выполнения конкретной операции, и время, необходимое для сборки данных из разных сервисов.

Вывод:

    В монолитном подходе производительность приложения оценивается как единое целое, что может упростить процесс оптимизации, но также ограничивает возможности масштабирования и гибкости.
    В микросервисном подходе производительность каждого сервиса оценивается отдельно, что позволяет более гибко управлять ресурсами и масштабировать отдельные компоненты, но требует дополнительных усилий по управлению взаимодействием и коммуникацией между сервисами.

\subsection{Масштабируемость}

Монолитный подход:

    Горизонтальное масштабирование: Оценить возможность добавления дополнительных серверов для распределения нагрузки и увеличения пропускной способности приложения.
    Вертикальное масштабирование: Измерить возможность увеличения ресурсов на сервере (процессор, память) для обработки большего количества запросов и данных.

Микросервисный подход:

    Гибкость добавления новых сервисов: Оценить удобство и скорость добавления новых сервисов для расширения функциональности и увеличения масштабируемости.
    Гибкость масштабирования отдельных сервисов: Измерить возможность масштабирования отдельных сервисов по мере увеличения нагрузки на них.

Вывод:

    В монолитном подходе масштабируемость ограничена возможностями горизонтального и вертикального масштабирования всего приложения целиком, что может привести к ограничениям в управлении ресурсами и недостаточной гибкости.
    В микросервисном подходе масштабируемость повышается за счет возможности добавления и масштабирования отдельных сервисов по мере необходимости, что обеспечивает более гибкое управление ресурсами и адаптацию к изменяющимся требованиям.

\subsection{Доступность}

Монолитный подход:

    Тестирование отказоустойчивости: Провести тестирование на отказы и сбои приложения, включая проверку реакции системы на непредвиденные обстоятельства, такие как отключение серверов или сетевых узлов.
    Мониторинг доступности: Оценить доступность приложения в реальном времени с помощью мониторинговых инструментов, таких как системы мониторинга производительности и управления событиями.

Микросервисный подход:

    Тестирование отказоустойчивости каждого сервиса: Провести тестирование отказоустойчивости каждого сервиса отдельно, включая проверку реакции на сбои и ошибки.
    Балансировка нагрузки: Использовать механизмы балансировки нагрузки для обеспечения равномерного распределения нагрузки между сервисами и предотвращения перегрузок.

Вывод:

    В монолитном подходе доступность приложения оценивается как единое целое, что может упростить процесс управления и контроля, но также увеличивает риск целостного отказа системы при сбое.
    В микросервисном подходе каждый сервис оценивается отдельно по его доступности, что позволяет более точно контролировать и управлять отказами и сбоями, но также требует дополнительных усилий по управлению и мониторингу.

\subsection{Техническое обслуживание}

Монолитный подход:

    Сложность обновлений и патчей: Оценить сложность процесса обновления и установки патчей для всего приложения целиком, включая возможность автоматизации этих процессов.
    Общее время простоя: Измерить время простоя приложения во время обновлений и технического обслуживания для определения общего влияния на производственные процессы.

Микросервисный подход:

    Управление версиями сервисов: Оценить возможность управления версиями сервисов и их зависимостями, включая автоматизацию процессов обновления и деплоймента.
    Мониторинг здоровья сервисов: Использовать мониторинговые инструменты для отслеживания здоровья каждого сервиса и оперативного реагирования на сбои и проблемы.

Вывод:

    В монолитном подходе техническое обслуживание оценивается как единое целое, что может упростить процесс управления и контроля, но также увеличивает риск простоев системы при обновлениях.
    В микросервисном подходе управление и мониторинг сервисов может быть более гибким и эффективным, но также требует дополнительных усилий по организации и автоматизации процессов обслуживания.

\subsection{Переносимость}

Монолитный подход:

    Тестирование на разных платформах: Проверить работоспособность приложения на различных операционных системах и аппаратных платформах для определения степени переносимости.
    Использование кросс-платформенных технологий: Оценить использование кросс-платформенных технологий и инструментов разработки для обеспечения универсальности приложения.

Микросервисный подход:

    Независимость от платформы: Проверить, насколько каждый сервис является независимым от платформы, и как легко его можно перенести на другие среды выполнения.
    Стандартизация интерфейсов: Использовать стандартизированные протоколы и интерфейсы для обеспечения совместимости и переносимости сервисов.

Вывод:

    В монолитном подходе переносимость приложения оценивается как единое целое, что может упростить процесс тестирования и обеспечения совместимости, но также может ограничить возможности адаптации к различным средам выполнения.
    В микросервисном подходе каждый сервис оценивается отдельно по его переносимости, что позволяет более гибко управлять совместимостью и адаптацией к различным платформам, но также требует дополнительных усилий по обеспечению независимости и стандартизации.

\subsection{Надежность}

Монолитный подход:

    Тестирование отказоустойчивости: Провести тестирование на отказы и сбои приложения, включая проверку реакции системы на непредвиденные обстоятельства, такие как отключение серверов или сетевых узлов.
    Мониторинг и регистрация ошибок: Установить систему мониторинга и регистрации ошибок для отслеживания и анализа сбоев и ошибок в работе приложения.

Микросервисный подход:

    Тестирование отказоустойчивости каждого сервиса: Провести тестирование отказоустойчивости каждого сервиса отдельно, включая проверку его реакции на сбои и ошибки.
    Изоляция сбоев: Обеспечить изоляцию сбоев в отдельных сервисах для предотвращения распространения проблем на всю систему.

Вывод:

    В монолитном подходе надежность приложения оценивается как единое целое, что может упростить процесс мониторинга и анализа сбоев, но также увеличивает риск целостного отказа системы при сбое.
    В микросервисном подходе каждый сервис оценивается отдельно по его надежности, что позволяет более точно контролировать и управлять сбоями и проблемами, но также требует дополнительных усилий по организации и мониторингу.

\subsection{Юзабилити}

Монолитный подход:

    Тестирование пользовательского интерфейса: Провести тестирование пользовательского интерфейса приложения на соответствие стандартам юзабилити, включая проверку навигации, удобства использования элементов управления и визуального дизайна.
    Сбор обратной связи от пользователей: Провести опросы и интервью с пользователями для оценки их удовлетворенности и определения улучшений, которые можно внести в интерфейс приложения.

Микросервисный подход:

    Тестирование интерфейсов каждого сервиса: Провести тестирование интерфейсов каждого сервиса на удобство использования и соответствие потребностям конечных пользователей.
    Интеграционное тестирование: Провести тестирование взаимодействия между сервисами и оценить удобство использования системы в целом, включая процессы аутентификации, авторизации и передачи данных между сервисами.

Вывод:

    В монолитном подходе юзабилити оценивается как единое целое, что может упростить процесс тестирования и улучшения пользовательского опыта, но также может привести к более сложной навигации и интерфейсу.
    В микросервисном подходе каждый сервис оценивается отдельно по его юзабилити, что позволяет более точно адаптировать интерфейсы к потребностям пользователей, но также требует дополнительных усилий по интеграционному тестированию и обеспечению консистентности интерфейсов.

\subsection{Совместимость}

Монолитный подход:

    Тестирование на разных платформах: Проверить работоспособность приложения на различных операционных системах и браузерах для определения степени совместимости.
    Проверка совместимости с различными устройствами: Оценить работоспособность приложения на различных типах устройств (настольные компьютеры, планшеты, мобильные телефоны) и разрешениях экранов.

Микросервисный подход:

    Совместимость интерфейсов сервисов: Проверить совместимость интерфейсов и протоколов взаимодействия между сервисами для обеспечения их корректной работы в различных средах выполнения.
    Тестирование совместимости с внешними системами: Провести тестирование взаимодействия с внешними системами и сервисами для определения совместимости и обеспечения корректной работы приложения в различных окружениях.

Вывод:

    В монолитном подходе совместимость оценивается как единое целое, что может упростить процесс тестирования и обеспечения совместимости, но также может ограничить возможности адаптации к различным средам выполнения.
    В микросервисном подходе совместимость каждого сервиса оценивается отдельно, что позволяет более точно контролировать и управлять совместимостью и адаптацией к различным средам, но также требует дополнительных усилий по тестированию и обеспечению совместимости интерфейсов.

\subsection{Юридические вопросы}

Монолитный подход:

    Аудит правовой соответствия: Провести аудит кода и архитектуры приложения для выявления возможных юридических проблем, таких как нарушение авторских прав или конфиденциальности данных.
    Проверка лицензий и соглашений: Проверить соответствие использованных технологий и компонентов лицензионным соглашениям и требованиям конкретных проектов.

Микросервисный подход:

    Контроль доступа и авторизации: Обеспечить корректное управление доступом к сервисам и данным в соответствии с требованиями конфиденциальности и безопасности.
    Защита данных: Обеспечить адекватную защиту персональных данных и конфиденциальной информации в каждом из сервисов.

Вывод:

    В монолитном подходе юридические вопросы оцениваются как единое целое, что может упростить процесс аудита и контроля, но также может увеличить риск возникновения проблем из-за несоответствия правовым требованиям.
    В микросервисном подходе каждый сервис оценивается отдельно с точки зрения юридической безопасности и соответствия, что позволяет более точно контролировать и управлять рисками, но также требует дополнительных усилий по обеспечению соответствия и контроля.














    \subsection{Краткое содержание}
    Архитектурные особенности: Сравнение основных архитектурных принципов и подходов между монолитной и микросервисной архитектурами.
    Гибкость и масштабируемость: Оценка гибкости и возможностей масштабирования каждой из архитектур при изменении требований и нагрузки.
    Управление и развертывание: Сравнение процессов управления, развертывания и обновления приложений в контексте монолитной и микросервисной архитектур.
    Отказоустойчивость и производительность: Оценка уровня отказоустойчивости и производительности каждой архитектуры при различных условиях эксплуатации.
    Развитие и поддержка: Рассмотрение сложностей и преимуществ развития и поддержки приложений на основе монолитной и микросервисной архитектур.

    Сопоставление ключевых характеристик и результатов для монолитного и микросервисного подходов в контексте выбранных проектов:

    Архитектурные особенности:
        Монолитная архитектура: Единое приложение собрано в одном контейнере, что облегчает начальное развертывание и управление.
        Микросервисная архитектура: Приложение разделено на отдельные микросервисы, обеспечивая гибкость и независимость компонентов.

    Гибкость и масштабируемость:
        Монолитная архитектура: Ограниченная гибкость при масштабировании отдельных компонентов. Необходимость масштабировать всё приложение целиком.
        Микросервисная архитектура: Высокая гибкость в масштабировании и изменении отдельных компонентов без влияния на другие.

    Управление и развертывание:
        Монолитная архитектура: Проще в управлении и развертывании благодаря единому контейнеру, но требует перезапуска всего приложения при обновлении.
        Микросервисная архитектура: Более сложное управление из-за большего количества сервисов, но обновления могут быть более гибкими и безотказными.

    Отказоустойчивость и производительность:
        Монолитная архитектура: Отказ одной части может привести к отказу всего приложения. Масштабируемость ограничена.
        Микросервисная архитектура: Более высокая отказоустойчивость за счет изоляции отдельных сервисов. Возможность гибкого масштабирования отдельных компонентов для оптимизации производительности.

    Развитие и поддержка:
        Монолитная архитектура: Проще в разработке и поддержке для небольших и простых приложений с ограниченными требованиями.
        Микросервисная архитектура: Больше сложностей в разработке и поддержке из-за необходимости управления множеством сервисов, но более подходит для крупных и распределенных систем.

\subsection{Анализ производительности, масштабируемости, поддерживаемости и других аспектов каждой архитектуры}
    Монолитная архитектура:
    
        Производительность: Приложение может столкнуться с проблемами производительности из-за неэффективного масштабирования и обработки больших объемов данных в едином контейнере.
        Масштабируемость: Ограниченная масштабируемость из-за необходимости масштабировать всё приложение целиком, что может привести к избыточному использованию ресурсов.
        Поддерживаемость: Проще в поддержке из-за централизованной структуры, однако изменения в приложении могут потребовать пересборки и перезапуска всего приложения.
        Отказоустойчивость: Отказ одной части приложения может привести к полному отказу приложения, так как все компоненты работают в едином контексте.
    
    Микросервисная архитектура:
    
        Производительность: Более гибкая и эффективная производительность благодаря изоляции сервисов и возможности масштабирования только необходимых компонентов.
        Масштабируемость: Высокая масштабируемость, так как каждый сервис может быть масштабирован независимо от других, что позволяет оптимизировать использование ресурсов.
        Поддерживаемость: Более сложно в поддержке из-за необходимости управления множеством сервисов, но при правильном организации кода и процессов разработки это может быть облегчено.
        Отказоустойчивость: Более высокая отказоустойчивость за счет изоляции отдельных сервисов, что позволяет предотвратить полный отказ приложения из-за отказа одного компонента.

\subsection{Идентификация сильных и слабых сторон каждого подхода}
    Монолитная архитектура:

    Сильные стороны:
    
        Проще в разработке и начальном развертывании благодаря централизованной структуре.
        Меньше сложностей с управлением и развертыванием, так как всё приложение собрано в одном контейнере.
        Относительно более проста в поддержке для небольших и простых приложений с ограниченными требованиями.
    
    Слабые стороны:
    
        Ограниченная масштабируемость из-за необходимости масштабировать всё приложение целиком, что может привести к избыточному использованию ресурсов.
        Более сложно в управлении и поддержке при росте функциональности и увеличении объема данных.
        Больше риска полного отказа приложения из-за отказа одной из его частей.
    
    Микросервисная архитектура:
    
    Сильные стороны:
    
        Высокая гибкость и масштабируемость благодаря изоляции сервисов и возможности масштабирования только необходимых компонентов.
        Более высокая отказоустойчивость за счет изоляции отдельных сервисов, что позволяет предотвратить полный отказ приложения из-за отказа одного компонента.
        Более эффективное использование ресурсов при правильном масштабировании и настройке компонентов.
    
    Слабые стороны:
    
        Больше сложностей в управлении и развертывании из-за необходимости управления множеством сервисов и их зависимостей.
        Более высокие затраты на разработку и поддержку из-за необходимости управления множеством кодовых баз и интеграций между сервисами.
        Риск усложнения системы и возможности перехода к "монолитному" подходу при неправильном проектировании или неподходящем управлении.
        
% Обязательно добавляем это в конце каждой секции, чтобы 
% обеспечить переход на новую страницу
\clearpage