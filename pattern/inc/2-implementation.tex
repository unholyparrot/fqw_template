\section{Реализация}

    В данном разделе будут приведены описания два приложения, разработанные и реализованные под моим руководством. Будет рассказано про основные требования, выдвинутые к данным проектам, их структура, команды для работы с ними, описаны инструменты разработки и сервера, на которых проихводился деплой. Всё это будет использовано в следующих разделах в сравнительном анализе архитектур, чтобы сравнение происходило на прикладных примерах из практики.

\subsection{Монолит - Medmobil}

    \subsubsection{Общее описание}
    Разработка этого проекта началась с нуля. К нашей команде обратился заказчик с предложением разработать сайт для организации медицинских перевозок. Изначально данный проект представлялся в виде разового проекта, хотя после вывода MVP разработка продолжалась в качестве постоянной работы. Было необходимо реализовать сервис, который бы позволял осуществлять:
    \begin{itemize}
        \item просмотр нескольких информационных страниц;
        \item регистрация и авторизация пользователей, включая ролевую модель - обычные пользователи, владельцы услуг, их диспетчеры и администраторы;
        \item возможность создания заказа с многочисленными различными параметрами;
        \item возможность управления ролевой моделью в рамках полномочий роли авторизованного пользователя;
        \item возможность просмотра, отслеживания и редактирования заказов в зависимости от роли авторизованного пользователя.
    \end{itemize}
    Целью было создать аналог сервиса Яндекс.Go, но только для заказа медицинского транспорта для первозки больных в различном состоянии, как запланированных, так и экстренных. При этом спрос на медицинский транспорт оценивается сверху 100 заказами в день, поэтому данный проект был реализован под низкую загруженность.

    \subsubsection{План разработки}
    Первоначальная идея представляла собой следующий план действий:
    \begin{itemize}
        \item разработка теоретической модели базы данных;
        \item разработка User Stories для основных сценариев на основе представлений заказчика;
        \item создание базовой части проекта (инициализация проектов PSQL, Java, Vue и их связь);
        \item реализация MVP (создание моделей в базе данных, разработка бэкенда на Java и фронтенда на Vue);
        \item аренда сервера и деплой с открытым IP.
    \end{itemize}
    Помимо этого было принято решение использовать Github репозиторий для хранения кодовой базы, а также для проведения автоматических тестов и проверки кодстайла.
    По завершению разработки MVP был сформирован новый план, направленный на выпуск приложения в открытый мир:
    \begin{itemize}
        \item подключение авторизации и регистрации через сторонний сервис (Keycloak);
        \item снижение задержки между обнаружением ошибки в поведении программе и её ликвидацией;
        \item снижение ежемесячных трат на поддержание стендов для теста и прода;
        \item оптимизация скорости работы (в основном направлено на часть фронтенда).
    \end{itemize}

    \subsubsection{Требования}
    Требования к проекту менялись в соответствии с планами и уточнялись в процессе разработки. В начале приоритеты были направлены на сокращение времени и оптимизацию "фундамента" для будущей разработки. Поэтому, к нашей команде были выдвинуты следующие требования: 
    \begin{itemize}
        \item скорость разработки;
        \item разработка расширяемой архитектуры;
        \item применении принципов разработки (DRY, YAGNI, SOLID) с целью создания удобочитаемого, поддерживаемого кода.
    \end{itemize}
    После создания кодовой базы и вывода первоначальной версии на стенд прода, требования были изменены в сторону поддержки уже существующей кодовой базы:
    \begin{itemize}
        \item повышение совместимости для упрощения совместимости с внешними сервисами (Keycloak);
        \item повышение наблюдаемости для увеличения скорости нахождения и исправления ошибок;
        \item уменьшение потребления ресурсов.
    \end{itemize}

    \subsubsection{Архитектура}
    Выбор архитектуры происходил в соответствии с требованиями, представленными выше. Поэтому была выбрана монолитная архитектура (подробнее про причины выбора будет рассказано в разеделе Анализ). Итоговая структура репозитория выглядела так:
    \newline \newline
    \begin{forest}
    [
      [src/
        [main/
          [...]
        ]
        [test/
          [...]
        ]
      ]
      [vueMedicalService/
        [package.json]
        [vue.config.js]
        [src/
          [...]
        ]
      ]
      [target/
        [...]
      ]
      [codestyle/
        [...]
      ]
    ]
    \end{forest}
    
    Как видно, все файлы лежат в одном репозитории. Папка src/ содержит все файлы, относящиеся к бэкенду - проекту на Java. Папка vueMedicalService содержит все файлы, относящиеся к фронтенду - проекту на Vue.js. Также есть общие файлы, которые относятся к проекту в целом - папка target/ содержит итоговые собранные файлы, codestyle/ содержит скрипты и конфигурационные файлы для проверки стиля кода.



    \subsection{Микросервисы}
    
    \subsubsection{Общее описание}
    Разработка данного проекта началась практически с нуля. Единственное, что было дано нашей команде - это две заготовки под микросервисы, которые не были объединены никоим образом и содержали лишь базовую логику GET/SET для простой таблице в базе данных. К нашей команде обратился заказчик с предложением разработать сайт для каталогизации и структуризации данных различных производств. Идея заключается в создании единого каталога для всевозможных технологических процессов, материалов и деталей, которые соединяются в единую производственную цепочку в соответствии с параметрами и характеристиками данной сущности.

    Было необходимо реализовать сервис, который бы позволял осуществлять:
    \begin{itemize}
      \item просмотр нескольких информационных страниц;
      \item регистрация и авторизация пользователей, включая ролевую модель - обычные пользователи и администраторы;
      \item возможность управления ролевой моделью в рамках полномочий роли авторизованного пользователя; 
      \item возможность добавления новых сущностей и параметров (в случае наличия достаточных прав);
      \item возможность просмотра, поиска и отображения в GUI (в табличном виде, а объектов, имеющих географическое положение, в том числе и на карте) данных о сущностях.
    \end{itemize}

    \subsubsection{План разработки}
    План разработки изначально был более детализированный и продуманный на больший срок, поскольку было необходимо разрабатывать платформу для будущей тяжеловесной системы, анализирующей большие данные. По этой же причине уже заказчиком была выбрана микросервисная архитектура. Тем не менее, мы вели разработку в условиях низкой загруженности, поскольку разработкой анализа больших данных должна была заниматься другая команда, после окончания нашей рзработки системы в целом. План разработки:
    \begin{itemize}
        \item разработка теоретической модели базы данных с учётом специфики проекта (неопределённое количество параметров каждой сущности, необходимость рекурсивно вложенных отношений);
        \item разработка User Stories для основных сценариев на основе представлений заказчика;
        \item разработка микросервисов, необходимых для поддержания базы данных и операций, необходимых для корректного манипулирования данными
        \item создание базовой части проекта (инициализация проектов PSQL, Java, Vue);
        \item разработка и создание сервисов, необходимых для корректной связи микросервисов (Eureka, API Gateway, Config)
        \item подключение авторизации и регистрации через сторонний сервис (Keycloak);
        \item реализация MVP (создание моделей в базе данных, разработка бэкенда на Java и фронтенда на Vue);
        \item аренда сервера и деплой с открытым IP.
    \end{itemize}
    Также было принято решение использовать Gitlab репозиторий для хранения кодовой базы, а также для проведения автоматических тестов и проверки кодстайла.

    \subsubsection{Требования}
    Требования к проекту формировались в соответствии с планами. Были сразу поставлены приоритеты на проектирование системы с ориентиром на последующую доработку проекта в высоконагруженный сервис. Поэтому, к нашей команде были выдвинуты следующие требования: 
    \begin{itemize}
        \item разработка расширяемой архитектуры;
        \item применении принципов разработки (DRY, YAGNI, SOLID) с целью создания удобочитаемого, поддерживаемого кода;
        \item обеспечение совместимости кода для интеграции с внешними сервисами (Keycloak);
        \item повышение наблюдаемости для увеличения скорости нахождения и исправления ошибок;
        \item уменьшение потребления ресурсов;
        \item возможность масштабирования.
    \end{itemize}

    \subsubsection{Архитектура}
    Для данного проекта была выбрана микросервисная архитектура (подробнее про причины выбора будет рассказано в разеделе Анализ). Итоговая структура репозитория выглядела так:
    \newline \newline
    \begin{forest}
    [
      [java/
        [docker-compose.yml]
        [docker/
          [Dockerfile]
          [Dockerfile-keycloak]
        ]
        [utils/
          [\{java\_project\}]
        ]
        [eureka/
          [\{java\_project\}]
        ]
        [gateway/
          [\{java\_project\}]
        ]
        [microservices/
          [amqp-service/
            [\{java\_project\}]
          ]
          [company-data/
            [\{java\_project\}]
          ]
          [import-data/
            [\{java\_project\}]
          ]
          [master-data/
            [\{java\_project\}]
          ]
          [service-auth/
            [\{java\_project\}]
          ]
        ]
      ]
      [vue/
        [...]
      ]
    ]
    \end{forest}
    \newline
    где сокращение [java\_project] означает стандартный Java проект: pom.xml и папка src/, в которой хранится вся кодовая база.
    
    Видно, что существует множество различных папок в бэкенде на Java, так как появилось множество отдельных подпроектов, которые отвечают за микросервисы. Также есть общие файлы, которые относятся к проекту в целом - папка utils/ содержит общие классы, docker/ содержит файлы для docker-compose.



    \subsection{Корректность}
    Как видно из приведённого выше описания, данные проекты очень похожи друг на друга: оба были целиком созданы мной и моей командой, используется одинаковый стэк. План разработки похож, хотя во втором проекте и присутствует больше шагов ввиду усложнённой структуры проекта с микросервисной архитектурой (подробнее будет в разделе Анализ). Архитектура проектов не имеет принципиальных дополнений по сравнению с базовым проектом Java, но заметно, что во втором проекте больше файлов и папок.



% Обязательно добавляем это в конце каждой секции, чтобы 
% обеспечить переход на новую страницу
\clearpage